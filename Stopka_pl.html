<!doctype html>
<html lang="pl">
<head>
   <meta charset="utf-8">
   <link rel="stylesheet" href="style_stopka.css">
   <title>Stopka po polsku</title>
</head>

   <body>

      <h1 style="color:Blue;">Dlaczego 'GW-Basic' i 'C'?</h1>

      <h2 style="color:Green;">Deweloperka wobec programowania</h2>
      <p>Za proces programowania można uznać tworzenie kodów w szerokim zakresie ich zastosowania (praktycznie nieograniczonym tematycznie) z możliwością różnorodnego toru prowadzącego do podobnych wyników - co zależy od programisty, możliwości rozbudowy funkcjonalności kodu w określanych kierunkach, zwykle z góry przewidzianych, ilości pochłanianych zasobów (pamięć, implementacja zewnętrznych procedur), czasochłonności procesu itp.<br/></p>
      <hr>
      <p>Na drugim biegunie znajdzie się proces budowania rezultatu przy pomocy gotowych modułów, 'podzespołów' w ściśle ograniczonym celu. Przykładem może być tu 'Django': krok1, krok2,..., krokN i rezultat strony internetowej gotowy. Gdzie tu klasyczne programowanie? Co prawda, jest tu dodawanych wiele obrazków i rutynowych tekstów, ale one mogą być traktowane jak jeden zmieniający się element, tak jak w pętli 'for'. Jedna pętla 'for' nie czyni kodu programowaniem... Ten proces to raczej 'operowanie' a nie 'programowanie'.  Jedną z zalet Python'a jest filozofia 'batteries included' w postaci możliwości dołączenia (import) ponad 120 000 pakietów (packages), zwykle z wieloma funkcjami w każdym z nich.</p>
      <hr>
      <p>Obecny pracownik IT to ktoś pomiędzy 'programistą' a 'operatorem'. Takiego kogoś nazwano 'deweloperem'. Tak więc firmy rekrutują na stanowiska: Java Developer,  Python Developer (ze względu na gotową już funkcjonalność modułów), COBOL Developer (ze względu na wyjątkowo ograniczone zastosowanie tego języka) i innych 'developers'.  Z dużą przesadą, ironicznie stwierdzę, że fan Harrego Pottera będzie dobrym pracownikiem IT - wystarczy znać zaklęcia (wbudowane lub importowane funkcje i ich składnie).</p>
      <p>A więc programowanie czy obsługa...?</p>
      <hr>
      <p><b>Jednak nadal poszukiwani są obecnie 'programiści C' jak niegdyś 'programiści GW-Basic'.</b></p>
      <p><b>Darmowe emulatory: Borland TurboC++ wersja 3.0 z 1991 roku i GW-Basic z 1988 roku działają bezbłędnie na najnowszych komputerach.</b></p>
      <p><b>Wersja 'Dev C++' Microsoftu bez grafiki jest ogólnodostępna. Jest jednak jedno 'ale': Aktualnie nie ma bezpłatnego jednego pakietu graficznego na dowolny PC.  'libbgi.a' na 32-bitowy komputer nie będzie działać na 64-bitowym.</b></p>
      <br><br>


      <h2 style="color:Green;">Czasy się zmieniają</h2>

      <h3 style="color:BlueViolet;">1. Aktywność programistyczna poza miejscem pracy.</h3>
      <p>Niegdyś, gdy ogólnodostępny Internet dopiero powstawał, wysyłałem czasem swoje pojedyncze tematycznie kody (właśnie takie jak na tej stronie Internetowej) do firm razem z CV*. To jednak spotkało się z totalną ignorancją ze strony tych firm.
      <br>Obecnie wiele firm zatrudniających ludzi IT pyta się o kody w 'GitHub' kandydata lub jego prywatną stronę internetową.</p>

      <h3 style="color:BlueViolet;">2. Koszty stosowania wbudowanych funkcji.</h3>

      <h3 style="color:Peru;"><b>a) Mniej lub bardziej potrzebne moduły.</b></h3>
      <p>Każdy język programowania składa się z tzw. 'primitives' (najbardziej proste elementy dostępne w danym języku programowania, jak aksjomaty w matematyce), na bazie których zbudowane są takie popularne (wszędzie, od COBOLa do Pythona**) funkcje jak 'reverse', 'UpperCase' czy 'LoverCase' - tak proste do zdefiniowania i tak mało używane, że aż dziwi ich obecność.</p>

      <h3 style="color:Peru;"><b>b) Koszt pamięci.</b></h3>
      <p>Utworzyłem prostą stronę w HTML i sprawdziłem 'właściwości' tego folderu (wartości przybliżone):<br>- Rozmiar: 140 KB<br>- Zawiera: 20 plików, 9 folderów</p>
      <p>Podobną stronę zbudowałem importując React (import React from "react";). Wcześniej musiałem uruchomić 'npx create-react-app' na moim folderze:<br>- Rozmiar: 224 MB<br>- Zawiera: 36 814 plików, 4 866 folderów<br><b>Szok!</b></p>

      <h3 style="color:Peru;"><b>c) Brak możliwości zmian i rozbudowy wbudowanych funkcji.</b></h3>
      <p>Własny kod można zmienić/rozbudować w dowolnym kierunku.</p>
      <p>Chcąc zmienić wbudowane funkcje, najpierw opanuj - jak powyżej - kod niemal 37000 plików w 5000 folderach. Powodzenia!</p>

      <h3><b>Wydajność procesu jest tu trudna do kontrolowania - wręcz się o nią nie dba.</b></h3>
      <br><hr>

      <p>* Tak więc przedstawione tu moje kody mogą być już od wielu lat dostępne dla bliżej nieokreślonej liczby osób.</p>
      <p>** Pomiędzy nimi są tu języki mało dzisiaj popularne (Prolog, R, Pascal, itd), aplikacje jednego sezonu (np. PowerBuilder) jak i niemal zapomniane FORTRAN i Algol środowiska mainframe, bez których nie byłoby dzisiejszego IT, bo wszystko, co było zrobione wcześniej, zwykle było kopiowane do tego, co robiono później. Np. operacje na łańcuchach znakowych: REXX --> ... --> R --> Python.</p>
      <br><br>


      <h2 style="color:Green;">Wszechstronność to wróg schematów</h2>

      <p><b>Programowanie</b> powinno sprzyjać <b>modelowaniu</b> bo to wspiera naukę na potrzeby technologii. Jak na razie ta ostatnia, rozwija się po najmniejszej linii oporu wspomagając często wątpliwe etycznie sektory. Nauka rozwija się zbyt wolno aby zapobiec temu chaosowi.</p>
      <p><b>Modelowanie</b> (wprowadzanie interakcyjnych elementów) to nasz najlepszy sposób na odnalezienie relacji z prawami Natury.</p>
      <p><b>Programowanie</b> to naturalny sposób na wsparcie modelowania tego, z czego istnienia zdajemy sobie sprawę, czego doświadczamy ale nie jesteśmy w stanie opanować inaczej niż tworząc modele coraz bliższe temu co zauważamy, a to wymaga nierutynowych zachowań. Dlatego naukowcy często chwytają się jakichkolwiek teorii z nadzieją, że ich praca może się kiedyś i na coś przydać.</p>
      <br><br>

   </body>

</html>
